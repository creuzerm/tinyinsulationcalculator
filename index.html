<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tiny Home Heat Loss Calculator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .input-group {
            margin-bottom: 1.5rem;
        }
        .input-label {
            display: block;
            margin-bottom: 0.5rem;
            color: #4A5568;
            font-weight: 500;
        }
        .input-field {
            width: 100%;
            padding: 0.75rem;
            border-radius: 0.375rem;
            border: 1px solid #E2E8F0;
            background-color: #F7FAFC;
            transition: border-color 0.2s;
        }
        .input-field:focus {
            outline: none;
            border-color: #4299E1;
            box-shadow: 0 0 0 1px #4299E1;
        }
        .heatLossChartBox {
            height: 600px; 
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800">

    <div class="container mx-auto p-4 md:p-8 max-w-4xl">
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-900">Tiny Home Heat Loss Calculator</h1>
            <p class="text-gray-600 mt-2">Estimate the heating load for your tiny home to size your heat pump correctly.</p>
        </header>

        <main class="grid grid-cols-1 lg:grid-cols-2 gap-8">
            <!-- Input Controls Column -->
            <div class="bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-2xl font-semibold mb-6 border-b pb-3">Building Specifications</h2>

                <!-- Building Shape Selector -->
                <div class="input-group">
                    <label for="buildingShape" class="input-label">Building Shape</label>
                    <select id="buildingShape" class="input-field">
                        <option value="rectangle">Simple Rectangle</option>
                        <option value="a-frame">A-Frame</option>
                        <option value="gothic-arch">Gothic Arch</option>
                    </select>
                </div>

                <!-- Dimension Inputs -->
                <div id="dimensionInputs">
                    <!-- Dynamic inputs will be injected here by JS -->
                </div>

                <h2 class="text-2xl font-semibold mb-6 mt-8 border-b pb-3">Climate & Comfort</h2>

                <!-- Temperature Inputs -->
                <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 input-group">
                    <div>
                        <label for="indoorTemp" class="input-label">Indoor Temp (°F)</label>
                        <input type="number" id="indoorTemp" class="input-field" value="68">
                    </div>
                    <div>
                        <label for="outdoorTemp" class="input-label">Outdoor Temp (°F)</label>
                        <input type="number" id="outdoorTemp" class="input-field" value="10">
                    </div>
                </div>

                <h2 class="text-2xl font-semibold mb-6 mt-8 border-b pb-3">Construction Details</h2>

                <!-- Wall Assembly Selector -->
                <div class="input-group">
                    <label for="wallAssembly" class="input-label">Insulation / Wall</label>
                    <select id="wallAssembly" class="input-field">
                        <option value="13">2x4 Walls (R-13)</option>
                        <option value="21">2x6 Walls (R-21)</option>
                        <option value="29">2x8 Walls (R-29)</option>
                        <option value="custom">Custom R-Value</option>
                        <option value="double-wall">Double Stud Wall (No Thermal Bridge)</option>
                    </select>
                </div>
                <div id="customRValueContainer" class="input-group hidden">
                    <label for="customRValue" class="input-label">Custom Wall R-Value</label>
                    <input type="number" id="customRValue" class="input-field" value="21">
                </div>
                 <div id="doubleWallContainer" class="input-group hidden">
                    <label for="doubleWallRValue" class="input-label">Double Wall Insulation R-Value</label>
                    <input type="number" id="doubleWallRValue" class="input-field" value="40">
                </div>

                <!-- Openings Selector -->
                <div class="input-group">
                    <label for="openingsArea" class="input-label">Openings (Windows & Doors) - General Area %</label>
                    <select id="openingsArea" class="input-field">
                        <option value="10">10% of Surface Area (Minimal)</option>
                        <option value="15" selected>15% of Surface Area (Common)</option>
                        <option value="20">20% of Surface Area (Generous)</option>
                        <option value="25">25% of Surface Area (Lots of Glass)</option>
                        <option value="custom">Custom Areas Below</option>
                    </select>
                    <small class="text-gray-500">Select 'Custom Areas Below' to input specific door/window details.</small>
                </div>

                <div id="customOpeningsContainer" class="hidden">
                    <h3 class="text-xl font-semibold mb-4 mt-6 border-b pb-2">Window Details</h3>
                    <div class="grid grid-cols-1 sm:grid-cols-3 gap-4 input-group">
                        <div>
                            <label for="numWindows" class="input-label">Number of Windows</label>
                            <input type="number" id="numWindows" class="input-field" value="3">
                        </div>
                        <div>
                            <label for="windowArea" class="input-label">Area per Window (sq ft)</label>
                            <input type="number" id="windowArea" class="input-field" value="10">
                        </div>
                        <div>
                            <label for="windowRValue" class="input-label">Window R-Value</label>
                            <input type="number" id="windowRValue" class="input-field" value="2.5">
                        </div>
                    </div>

                    <h3 class="text-xl font-semibold mb-4 mt-6 border-b pb-2">Door Details</h3>
                    <div class="grid grid-cols-1 sm:grid-cols-3 gap-4 input-group">
                        <div>
                            <label for="numDoors" class="input-label">Number of Doors</label>
                            <input type="number" id="numDoors" class="input-field" value="1">
                        </div>
                        <div>
                            <label for="doorArea" class="input-label">Area per Door (sq ft)</label>
                            <input type="number" id="doorArea" class="input-field" value="20">
                        </div>
                        <div>
                            <label for="doorRValue" class="input-label">Door R-Value</label>
                            <input type="number" id="doorRValue" class="input-field" value="5">
                        </div>
                    </div>
                </div>


                <h2 class="text-2xl font-semibold mb-6 mt-8 border-b pb-3">Qualitative Factors</h2>

                <!-- Qualitative Factors -->
                <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 input-group">
                    <div>
                        <label for="airSealing" class="input-label">Air Sealing</label>
                        <select id="airSealing" class="input-field">
                            <option value="good">Good Air Barrier</option>
                            <option value="poor">Poor Air Barrier (Drafty)</option>
                        </select>
                    </div>
                    <div>
                        <label for="radiantBarrier" class="input-label">Radiant Barrier</label>
                        <select id="radiantBarrier" class="input-field">
                            <option value="no">No Reflective Barrier</option>
                            <option value="yes">Reflective Barrier Included</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- Results Column -->
            <div class="bg-white p-6 rounded-lg shadow-md flex flex-col">
                <h2 class="text-2xl font-semibold mb-6 border-b pb-3">Estimated Heat Loss</h2>
                <div class="flex-grow flex flex-col items-center justify-center text-center">
                    <div id="resultsDisplay" class="mb-4">
                        <p class="text-6xl font-bold text-blue-600">0</p>
                        <p class="text-xl text-gray-600">BTUs/hr</p>
                    </div>
                    <p id="resultsExplanation" class="max-w-md text-gray-500">
                        This is the approximate heating power your system needs to maintain the desired indoor temperature on the coldest day. Look for a heat pump with a capacity that meets or exceeds this value.
                    </p>
                </div>
                 <div class="mt-8 heatLossChartBox">
                    <h3 class="text-xl font-semibold text-center mb-4">Heat Loss vs. Outdoor Temperature</h3>
                    <canvas id="heatLossChart"></canvas>
                </div>

                <!-- New Section for Heat Loss Breakdown Table -->
                <div id="heatLossBreakdownContainer" class="mt-8 pt-6 border-t">
                    <h3 class="text-xl font-semibold text-center mb-4">Heat Loss Breakdown by Surface</h3>
                    <div id="heatLossBreakdownTable" class="overflow-x-auto">
                        <!-- Table will be injected here by JS -->
                        <p class="text-center text-gray-500">Calculating breakdown...</p>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Element References ---
            const buildingShape = document.getElementById('buildingShape');
            const dimensionInputsContainer = document.getElementById('dimensionInputs');
            const indoorTemp = document.getElementById('indoorTemp');
            const outdoorTemp = document.getElementById('outdoorTemp');
            const wallAssembly = document.getElementById('wallAssembly');
            const customRValueContainer = document.getElementById('customRValueContainer');
            const customRValue = document.getElementById('customRValue');
            const doubleWallContainer = document.getElementById('doubleWallContainer');
            const doubleWallRValue = document.getElementById('doubleWallRValue');
            const openingsArea = document.getElementById('openingsArea');
            const airSealing = document.getElementById('airSealing');
            const radiantBarrier = document.getElementById('radiantBarrier');
            const resultsDisplay = document.getElementById('resultsDisplay').querySelector('p:first-child');
            const customOpeningsContainer = document.getElementById('customOpeningsContainer');
            const numWindows = document.getElementById('numWindows');
            const windowArea = document.getElementById('windowArea');
            const windowRValue = document.getElementById('windowRValue');
            const numDoors = document.getElementById('numDoors');
            const doorArea = document.getElementById('doorArea');
            const doorRValue = document.getElementById('doorRValue');

            let heatLossChart;

            // --- Dimension Templates ---
            const dimensionTemplates = {
                rectangle: `
                    <div class="grid grid-cols-1 sm:grid-cols-3 gap-4 input-group">
                        <div><label class="input-label">Length (ft)</label><input type="number" id="length" class="input-field" value="20"></div>
                        <div><label class="input-label">Width (ft)</label><input type="number" id="width" class="input-field" value="10"></div>
                        <div><label class="input-label">Height (ft)</label><input type="number" id="height" class="input-field" value="8"></div>
                    </div>
                    <div class="input-group">
                        <label for="roofPitch" class="input-label">Roof Pitch (e.g., 4 for 4/12)</label>
                        <input type="number" id="roofPitch" class="input-field" value="4">
                        <small class="text-gray-500">For under-roof insulation calculation.</small>
                    </div>
                `,
                'a-frame': `
                    <div class="grid grid-cols-1 sm:grid-cols-3 gap-4 input-group">
                        <div><label class="input-label">Length (ft)</label><input type="number" id="length" class="input-field" value="20"></div>
                        <div><label class="input-label">Base Width (ft)</label><input type="number" id="width" class="input-field" value="12"></div>
                        <div><label class="input-label">Height (ft)</label><input type="number" id="height" class="input-field" value="15"></div>
                    </div>
                `,
                'gothic-arch': `
                    <div class="grid grid-cols-1 sm:grid-cols-3 gap-4 input-group">
                        <div><label class="input-label">Length (ft)</label><input type="number" id="length" class="input-field" value="20"></div>
                        <div><label class="input-label">Width (ft)</label><input type="number" id="width" class="input-field" value="12"></div>
                         <div><label class="input-label">Spring Wall Ht (ft)</label><input type="number" id="springWallHeight" class="input-field" value="2"></div>
                    </div>
                `
            };

            // --- Functions ---

            // Function to save input value to localStorage
            function saveInputToLocalStorage(element) {
                if (element && element.id) {
                    localStorage.setItem(element.id, element.value);
                }
            }

            // Function to load input value from localStorage
            function loadInputFromLocalStorage(element) {
                if (element && element.id) {
                    const savedValue = localStorage.getItem(element.id);
                    if (savedValue !== null) {
                        element.value = savedValue;
                    }
                }
            }

            function toggleCustomOpenings() {
                if (openingsArea.value === 'custom') {
                    customOpeningsContainer.classList.remove('hidden');
                } else {
                    customOpeningsContainer.classList.add('hidden');
                }
                calculateAll(); // Recalculate when toggling
            }


            function calculateHeatLossForTemperature(deltaT, surfaceAreas, wallRVal, openingsData, airSealingValue) {
                // openingsData can be:
                // 1. { type: "percentage", fraction: 0.15, rValue: 3 }
                // 2. { type: "custom", windows: { area: X, rValue: Y }, doors: { area: Z, rValue: A } }

                let componentLosses = {
                    totalLoss: 0,
                    wallLoss: 0, // Insulated part of walls
                    roofLoss: 0, // Insulated part of roof
                    endWallLoss: 0, // Insulated part of end walls
                    windowLoss: 0,
                    doorLoss: 0,
                    genericOpeningsLoss: 0 // Used if openingsData.type is "percentage"
                };

                let currentTotalLossPrePenalty = 0;
                let totalActualOpeningArea = 0;

                if (openingsData.type === 'custom') {
                    totalActualOpeningArea = (openingsData.windows?.area || 0) + (openingsData.doors?.area || 0);
                } else { // percentage
                    totalActualOpeningArea = surfaceAreas.total * openingsData.fraction;
                }

                // Ensure opening area does not exceed total surface area (important for custom inputs)
                if (totalActualOpeningArea > surfaceAreas.total) {
                    totalActualOpeningArea = surfaceAreas.total; // Cap it
                }


                // Calculate effective opaque surface area (total surface area - actual opening area)
                // This opaque area is what's covered by general wall/roof/endwall insulation.
                const totalOpaqueArea = Math.max(0, surfaceAreas.total - totalActualOpeningArea);

                // Distribute this opaque area proportionally to walls, roof, end-walls
                // if total surface area is not zero, otherwise opaque areas are zero.
                let opaqueWallArea = 0;
                let opaqueRoofArea = 0;
                let opaqueEndWallArea = 0;

                if (surfaceAreas.total > 0) {
                    opaqueWallArea = (surfaceAreas.wall / surfaceAreas.total) * totalOpaqueArea;
                    opaqueRoofArea = (surfaceAreas.roof / surfaceAreas.total) * totalOpaqueArea;
                    opaqueEndWallArea = (surfaceAreas.endWall / surfaceAreas.total) * totalOpaqueArea;
                }


                // Loss through INSULATED portion of Walls
                if (opaqueWallArea > 0 && wallRVal > 0) {
                    const loss = (opaqueWallArea * deltaT) / wallRVal;
                    componentLosses.wallLoss = loss;
                    currentTotalLossPrePenalty += loss;
                }

                // Loss through INSULATED portion of Roof
                // Assuming roof has same R-value as walls for simplicity in this model
                if (opaqueRoofArea > 0 && wallRVal > 0) {
                    const loss = (opaqueRoofArea * deltaT) / wallRVal;
                    componentLosses.roofLoss = loss;
                    currentTotalLossPrePenalty += loss;
                }

                // Loss through INSULATED portion of End Walls
                // Assuming end walls have same R-value as main walls
                if (opaqueEndWallArea > 0 && wallRVal > 0) {
                    const loss = (opaqueEndWallArea * deltaT) / wallRVal;
                    componentLosses.endWallLoss = loss;
                    currentTotalLossPrePenalty += loss;
                }


                // Loss through Openings
                if (openingsData.type === 'custom') {
                    if (openingsData.windows && openingsData.windows.area > 0 && openingsData.windows.rValue > 0) {
                        const loss = (openingsData.windows.area * deltaT) / openingsData.windows.rValue;
                        componentLosses.windowLoss = loss;
                        currentTotalLossPrePenalty += loss;
                    }
                    if (openingsData.doors && openingsData.doors.area > 0 && openingsData.doors.rValue > 0) {
                        const loss = (openingsData.doors.area * deltaT) / openingsData.doors.rValue;
                        componentLosses.doorLoss = loss;
                        currentTotalLossPrePenalty += loss;
                    }
                } else { // percentage based
                    if (totalActualOpeningArea > 0 && openingsData.rValue > 0) {
                        const loss = (totalActualOpeningArea * deltaT) / openingsData.rValue;
                        componentLosses.genericOpeningsLoss = loss;
                        currentTotalLossPrePenalty += loss;
                    }
                }

                // Apply air sealing penalty to all calculated losses
                if (airSealingValue === 'poor') {
                    componentLosses.wallLoss *= 1.25;
                    componentLosses.roofLoss *= 1.25;
                    componentLosses.endWallLoss *= 1.25;
                    componentLosses.windowLoss *= 1.25;
                    componentLosses.doorLoss *= 1.25;
                    componentLosses.genericOpeningsLoss *= 1.25;
                    currentTotalLossPrePenalty *= 1.25; // Apply to the sum for totalLoss
                }

                componentLosses.totalLoss = currentTotalLossPrePenalty;

                // Round all losses
                for (let key in componentLosses) {
                    componentLosses[key] = Math.round(componentLosses[key]);
                }
                return componentLosses;
            }


            function updateDimensionInputs() {
                dimensionInputsContainer.innerHTML = dimensionTemplates[buildingShape.value];
                // Load values for newly created dynamic inputs
                const dynamicInputs = dimensionInputsContainer.querySelectorAll('.input-field, input[type="number"]');
                dynamicInputs.forEach(input => loadInputFromLocalStorage(input));
                attachInputListeners(); // Attaches listeners which also handle saving
                calculateAll(); // Recalculate based on potentially loaded values
            }

            function getWallRValue() {
                let rValue = parseFloat(wallAssembly.value);
                if (wallAssembly.value === 'custom') {
                    customRValueContainer.classList.remove('hidden');
                    doubleWallContainer.classList.add('hidden');
                    rValue = parseFloat(customRValue.value) || 0;
                } else if (wallAssembly.value === 'double-wall') {
                    customRValueContainer.classList.add('hidden');
                    doubleWallContainer.classList.remove('hidden');
                    rValue = parseFloat(doubleWallRValue.value) || 0;
                } else {
                    customRValueContainer.classList.add('hidden');
                    doubleWallContainer.classList.add('hidden');
                }

                if (radiantBarrier.value === 'yes') {
                    rValue += 3;
                }
                return rValue;
            }

            function calculateSurfaceArea() {
                const shape = buildingShape.value;
                const L = parseFloat(document.getElementById('length')?.value) || 0;
                const W = parseFloat(document.getElementById('width')?.value) || 0;
                const H = parseFloat(document.getElementById('height')?.value) || 0; // For rectangle, eave height. For A-frame, overall peak height.
                const SWH = parseFloat(document.getElementById('springWallHeight')?.value) || 0; // For Gothic Arch

                let areas = {
                    total: 0,
                    wall: 0,        // Vertical walls (rectangle main walls, gothic spring walls)
                    roof: 0,        // Pitched/flat roof (rectangle), sloped surfaces (a-frame main), curved roof (gothic)
                    endWall: 0,     // Gable ends (rectangle), triangular ends (a-frame), semi-circular ends (gothic)
                                    // Note: For A-frame, 'roof' includes the primary sloped surfaces that function as walls+roof.
                                    // 'endWall' is for the typically triangular end caps.
                };

                switch (shape) {
                    case 'rectangle': {
                        const roofPitchValue = parseFloat(document.getElementById('roofPitch')?.value);
                        const roofPitch = !isNaN(roofPitchValue) && roofPitchValue >= 0 ? roofPitchValue : 0;

                        // Vertical walls (sum of 2*L*H and 2*W*H)
                        areas.wall = (2 * L * H) + (2 * W * H);

                        if (roofPitch === 0) { // Flat roof
                            areas.roof = L * W;
                            areas.endWall = 0; // No gables for a truly flat roof from these definitions
                        } else { // Pitched roof
                            const gableHeight = (W / 2) * (roofPitch / 12);
                            const rafterLength = Math.sqrt(Math.pow(W / 2, 2) + Math.pow(gableHeight, 2));
                            areas.roof = L * rafterLength * 2;
                            // Gable end walls (triangular part above the main H of the end walls)
                            // These are part of the 'endWall' category, distinct from the main 'wall' area.
                            areas.endWall = 2 * (0.5 * W * gableHeight);
                        }
                        break;
                    }
                    case 'a-frame': {
                        // H is the total height from base to peak. W is base width.
                        const slopeHeight = Math.sqrt(Math.pow(W / 2, 2) + Math.pow(H, 2));
                        areas.roof = 2 * L * slopeHeight; // These are the main sloped surfaces (roof/wall combined)

                        areas.endWall = 2 * (0.5 * W * H); // Triangular end walls
                        areas.wall = 0; // No separate vertical 'side' walls in a pure A-frame.
                        break;
                    }
                    case 'gothic-arch': {
                        // W is the full width of the arch base. SWH is height of vertical spring walls.
                        const radius = W / 2;

                        const archPerimeterSegment = Math.PI * radius; // Length of the arch (half circumference)
                        areas.roof = L * archPerimeterSegment; // Curved roof surface area

                        areas.endWall = Math.PI * Math.pow(radius, 2); // Area of two semi-circular end walls = one full circle

                        areas.wall = 2 * L * SWH; // Area of vertical spring walls (if SWH > 0)
                        break;
                    }
                }

                // Ensure all components are numbers and sum them for the total
                areas.wall = isNaN(areas.wall) ? 0 : areas.wall;
                areas.roof = isNaN(areas.roof) ? 0 : areas.roof;
                areas.endWall = isNaN(areas.endWall) ? 0 : areas.endWall;

                areas.total = areas.wall + areas.roof + areas.endWall;
                if (isNaN(areas.total)) areas.total = 0;

                return areas;
            }

            function calculateAll() {
                const surfaceAreas = calculateSurfaceArea(); // surfaceAreas is now an object: {total, wall, roof, endWall}

                if (!surfaceAreas || surfaceAreas.total <= 0) {
                    resultsDisplay.textContent = '0';
document.getElementById('heatLossBreakdownTable').innerHTML = '<p class="text-center text-gray-500">Enter valid dimensions to see breakdown.</p>';
if (heatLossChart) {
    heatLossChart.data.labels = [];
    heatLossChart.data.datasets = [];
    heatLossChart.update();
}
                    return;
                }

                const deltaT = Math.abs(parseFloat(indoorTemp.value) - parseFloat(outdoorTemp.value));
                const wallRVal = getWallRValue();
                const airSealingValue = airSealing.value;

                let openingsData = {};
                let totalCustomOpeningsArea = 0;

                if (openingsArea.value === 'custom') {
                    const numWin = parseFloat(numWindows.value) || 0;
                    const areaPerWin = parseFloat(windowArea.value) || 0;
                    const rValWin = parseFloat(windowRValue.value) || 0;
                    const numDr = parseFloat(numDoors.value) || 0;
                    const areaPerDr = parseFloat(doorArea.value) || 0;
                    const rValDr = parseFloat(doorRValue.value) || 0;

                    const totalWindowArea = numWin * areaPerWin;
                    const totalDoorArea = numDr * areaPerDr;
                    totalCustomOpeningsArea = totalWindowArea + totalDoorArea;

                    openingsData = {
                        type: "custom",
                        windows: { area: totalWindowArea, rValue: rValWin },
                        doors: { area: totalDoorArea, rValue: rValDr }
                    };
                } else {
                    openingsData = {
                        type: "percentage",
                        fraction: parseFloat(openingsArea.value) / 100,
                        rValue: 3 // Default R-value for percentage-based openings
                    };
                    totalCustomOpeningsArea = surfaceAreas.total * openingsData.fraction;
                }


                const heatLosses = calculateHeatLossForTemperature(
                    deltaT,
                    surfaceAreas,
                    wallRVal,
                    openingsData,
                    airSealingValue
                );

                let breakdown = {
                    components: [],
                    totalLoss: heatLosses.totalLoss,
                    totalArea: surfaceAreas.total, // This is total building envelope area
                    totalOpaqueArea: 0, // Will be calculated based on openings
                    totalOpeningsAreaUsed: 0 // Actual opening area used in calculation
                };

                // Calculate actual opaque and opening areas based on what calculateHeatLossForTemperature used
                let actualTotalOpeningArea = 0;
                if (openingsData.type === 'custom') {
                    actualTotalOpeningArea = (openingsData.windows?.area || 0) + (openingsData.doors?.area || 0);
                } else {
                    actualTotalOpeningArea = surfaceAreas.total * openingsData.fraction;
                }
                // Cap actual opening area if it exceeded total surface area
                actualTotalOpeningArea = Math.min(actualTotalOpeningArea, surfaceAreas.total);
                breakdown.totalOpeningsAreaUsed = actualTotalOpeningArea;
                breakdown.totalOpaqueArea = Math.max(0, surfaceAreas.total - actualTotalOpeningArea);


                // Populate breakdown.components
                // The areas for walls, roof, endwall should now be their *opaque* portions.
                // The heatLoss values are already adjusted for air sealing by calculateHeatLossForTemperature.

                let opaqueWallArea = 0;
                let opaqueRoofArea = 0;
                let opaqueEndWallArea = 0;

                if (surfaceAreas.total > 0) { // Avoid division by zero if total area is 0
                    opaqueWallArea = (surfaceAreas.wall / surfaceAreas.total) * breakdown.totalOpaqueArea;
                    opaqueRoofArea = (surfaceAreas.roof / surfaceAreas.total) * breakdown.totalOpaqueArea;
                    opaqueEndWallArea = (surfaceAreas.endWall / surfaceAreas.total) * breakdown.totalOpaqueArea;
                }


                if (opaqueWallArea > 0) { // Check against derived opaque area
                    breakdown.components.push({
                        name: "Insulated Walls",
                        area: opaqueWallArea,
                        heatLoss: heatLosses.wallLoss,
                        percentageOfTotalLoss: 0
                    });
                }
                if (opaqueRoofArea > 0) {
                    breakdown.components.push({
                        name: "Insulated Roof",
                        area: opaqueRoofArea,
                        heatLoss: heatLosses.roofLoss,
                        percentageOfTotalLoss: 0
                    });
                }
                if (opaqueEndWallArea > 0) {
                    breakdown.components.push({
                        name: "Insulated End Walls/Gables",
                        area: opaqueEndWallArea,
                        heatLoss: heatLosses.endWallLoss,
                        percentageOfTotalLoss: 0
                    });
                }

                if (openingsData.type === 'custom') {
                    if (openingsData.windows && openingsData.windows.area > 0) {
                        breakdown.components.push({
                            name: "Custom Windows",
                            area: openingsData.windows.area,
                            heatLoss: heatLosses.windowLoss,
                            percentageOfTotalLoss: 0
                        });
                    }
                    if (openingsData.doors && openingsData.doors.area > 0) {
                        breakdown.components.push({
                            name: "Custom Doors",
                            area: openingsData.doors.area,
                            heatLoss: heatLosses.doorLoss,
                            percentageOfTotalLoss: 0
                        });
                    }
                } else { // Percentage based
                    if (actualTotalOpeningArea > 0) { // Use actualTotalOpeningArea here
                         breakdown.components.push({
                            name: "Openings (General)",
                            area: actualTotalOpeningArea,
                            heatLoss: heatLosses.genericOpeningsLoss,
                            percentageOfTotalLoss: 0
                        });
                    }
                }

                // Calculate percentageOfTotalLoss for each component
                if (breakdown.totalLoss > 0) {
                    breakdown.components.forEach(comp => {
                        comp.percentageOfTotalLoss = (comp.heatLoss / breakdown.totalLoss) * 100;
                    });
                } else {
                     breakdown.components.forEach(comp => comp.percentageOfTotalLoss = 0);
                }

                resultsDisplay.textContent = Math.round(breakdown.totalLoss).toLocaleString();

                updateHeatLossBreakdownTable(breakdown);

                updateChart(surfaceAreas); // Pass the surfaceAreas object for charting
            }

            function updateHeatLossBreakdownTable(breakdown) {
                const tableContainer = document.getElementById('heatLossBreakdownTable');
                if (!tableContainer) return;

                if (!breakdown || !breakdown.components || breakdown.components.length === 0) {
                    tableContainer.innerHTML = '<p class="text-center text-gray-500">No breakdown data available. Adjust inputs.</p>';
                    return;
                }

                let tableHTML = `
                    <table class="min-w-full divide-y divide-gray-200">
                        <thead class="bg-gray-50">
                            <tr>
                                <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Surface</th>
                                <th scope="col" class="px-4 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">Area (sq ft)</th>
                                <th scope="col" class="px-4 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">Heat Loss (BTU/hr)</th>
                                <th scope="col" class="px-4 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">% of Total</th>
                            </tr>
                        </thead>
                        <tbody class="bg-white divide-y divide-gray-200">
                `;

                breakdown.components.forEach(comp => {
                    if (comp.area > 0) { // Only display components with area
                        tableHTML += `
                            <tr>
                                <td class="px-4 py-3 whitespace-nowrap text-sm font-medium text-gray-900">${comp.name}</td>
                                <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-500 text-right">${Math.round(comp.area).toLocaleString()}</td>
                                <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-500 text-right">${Math.round(comp.heatLoss).toLocaleString()}</td>
                                <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-500 text-right">${comp.percentageOfTotalLoss.toFixed(1)}%</td>
                            </tr>
                        `;
                    }
                });

                // Add a footer row for totals.
                // The total area displayed here is the sum of individual component areas shown in the table,
                // which should equal surfaceAreas.total (envelope area).
                let sumOfDisplayedAreas = 0;
                breakdown.components.forEach(comp => sumOfDisplayedAreas += comp.area);

                tableHTML += `
                        </tbody>
                        <tfoot class="bg-gray-50">
                            <tr>
                                <td class="px-4 py-3 text-left text-sm font-bold text-gray-700">Total</td>
                                <td class="px-4 py-3 text-right text-sm font-bold text-gray-700">${Math.round(sumOfDisplayedAreas).toLocaleString()} sq ft</td>
                                <td class="px-4 py-3 text-right text-sm font-bold text-gray-700">${Math.round(breakdown.totalLoss).toLocaleString()} BTU/hr</td>
                                <td class="px-4 py-3 text-right text-sm font-bold text-gray-700">${breakdown.totalLoss > 0 ? '100.0%' : 'N/A'}</td>
                            </tr>
                        </tfoot>
                    </table>
                `;

                tableContainer.innerHTML = tableHTML;
            }

function updateChart(surfaceAreas) {
                const tempLabels = [];
                const datasets = [];
                const startTemp = parseFloat(outdoorTemp.value); // Use current outdoor temp as start for chart
                const currentIndoorTemp = parseFloat(indoorTemp.value);
                const maxTemp = Math.max(startTemp + 50, currentIndoorTemp + 20); // Ensure chart covers a reasonable range

                if (!surfaceAreas || surfaceAreas.total <= 0) {
                    if (heatLossChart) {
                        heatLossChart.data.labels = [];
                        heatLossChart.data.datasets = [];
                        heatLossChart.update();
                    }
                    return;
                }

                const colors = {
                    total: 'rgba(54, 162, 235, 1)',     // Blue
                    walls: 'rgba(255, 99, 132, 1)',    // Red
                    roof: 'rgba(75, 192, 192, 1)',     // Green
                    endWalls: 'rgba(255, 206, 86, 1)', // Yellow
                    windows: 'rgba(153, 102, 255, 1)', // Purple
                    doors: 'rgba(255, 159, 64, 1)',    // Orange
                    genericOpenings: 'rgba(130, 130, 130, 1)' // Grey
                };
                const backgroundColors = { // Lighter versions for fill
                    total: 'rgba(54, 162, 235, 0.2)',
                    walls: 'rgba(255, 99, 132, 0.2)',
                    roof: 'rgba(75, 192, 192, 0.2)',
                    endWalls: 'rgba(255, 206, 86, 0.2)',
                    windows: 'rgba(153, 102, 255, 0.2)',
                    doors: 'rgba(255, 159, 64, 0.2)',
                    genericOpenings: 'rgba(130, 130, 130, 0.2)'
                };

                let totalHeatLossData = [];
                let wallHeatLossData = [];
                let roofHeatLossData = [];
                let endWallHeatLossData = [];
                let windowHeatLossData = [];
                let doorHeatLossData = [];
                let genericOpeningsHeatLossData = [];

                const wallRVal = getWallRValue();
                const airSealingValue = airSealing.value;
                // Determine current openings configuration for the chart
                let openingsDataForChart = {};
                 if (openingsArea.value === 'custom') {
                    const numWin = parseFloat(numWindows.value) || 0;
                    const areaPerWin = parseFloat(windowArea.value) || 0;
                    const rValWin = parseFloat(windowRValue.value) || 0;
                    const numDr = parseFloat(numDoors.value) || 0;
                    const areaPerDr = parseFloat(doorArea.value) || 0;
                    const rValDr = parseFloat(doorRValue.value) || 0;
                    openingsDataForChart = {
                        type: "custom",
                        windows: { area: numWin * areaPerWin, rValue: rValWin },
                        doors: { area: numDr * areaPerDr, rValue: rValDr }
                    };
                } else {
                    openingsDataForChart = {
                        type: "percentage",
                        fraction: parseFloat(openingsArea.value) / 100,
                        rValue: 3 // Default R-value
                    };
                }


                for (let temp = Math.min(startTemp, currentIndoorTemp - 20) ; temp <= maxTemp; temp += 5) { // Chart across various outdoor temps
                    tempLabels.push(`${temp}°F`);
                    const deltaT = Math.abs(currentIndoorTemp - temp);

                    const heatLosses = calculateHeatLossForTemperature(
                        deltaT,
                        surfaceAreas,
                        wallRVal,
                        openingsDataForChart,
                        airSealingValue
                    );

                    totalHeatLossData.push(heatLosses.totalLoss);
                    wallHeatLossData.push(heatLosses.wallLoss);
                    roofHeatLossData.push(heatLosses.roofLoss);
                    endWallHeatLossData.push(heatLosses.endWallLoss);
                    windowHeatLossData.push(heatLosses.windowLoss);
                    doorHeatLossData.push(heatLosses.doorLoss);
                    genericOpeningsHeatLossData.push(heatLosses.genericOpeningsLoss);
                }

                datasets.push({
                    label: 'Total Heat Loss', data: totalHeatLossData,
                    borderColor: colors.total, backgroundColor: backgroundColors.total,
                    borderWidth: 3, fill: true, tension: 0.1, type: 'line'
                });

                // Helper to add dataset if its corresponding data array has non-zero sum
                const addDatasetIfRelevant = (label, dataArray, color, bgColor) => {
                    if (dataArray.some(val => val > 0)) {
                        datasets.push({
                            label: label, data: dataArray,
                            borderColor: color, backgroundColor: bgColor,
                            borderWidth: 1.5, fill: false, tension: 0.1, type: 'line', hidden: true
                        });
                    }
                };

                // Calculate actual opaque areas for labeling, similar to breakdown table logic
                let actualTotalOpeningAreaForChart = 0;
                if (openingsDataForChart.type === 'custom') {
                    actualTotalOpeningAreaForChart = (openingsDataForChart.windows?.area || 0) + (openingsDataForChart.doors?.area || 0);
                } else {
                    actualTotalOpeningAreaForChart = surfaceAreas.total * openingsDataForChart.fraction;
                }
                actualTotalOpeningAreaForChart = Math.min(actualTotalOpeningAreaForChart, surfaceAreas.total);
                const totalOpaqueAreaForChart = Math.max(0, surfaceAreas.total - actualTotalOpeningAreaForChart);

                let opaqueWallAreaForChart = 0;
                let opaqueRoofAreaForChart = 0;
                let opaqueEndWallAreaForChart = 0;

                if(surfaceAreas.total > 0){
                    opaqueWallAreaForChart = (surfaceAreas.wall / surfaceAreas.total) * totalOpaqueAreaForChart;
                    opaqueRoofAreaForChart = (surfaceAreas.roof / surfaceAreas.total) * totalOpaqueAreaForChart;
                    opaqueEndWallAreaForChart = (surfaceAreas.endWall / surfaceAreas.total) * totalOpaqueAreaForChart;
                }


                if (opaqueWallAreaForChart > 0) addDatasetIfRelevant('Insulated Wall Loss', wallHeatLossData, colors.walls, backgroundColors.walls);
                if (opaqueRoofAreaForChart > 0) addDatasetIfRelevant('Insulated Roof Loss', roofHeatLossData, colors.roof, backgroundColors.roof);
                if (opaqueEndWallAreaForChart > 0) addDatasetIfRelevant('Insulated End Wall/Gable Loss', endWallHeatLossData, colors.endWalls, backgroundColors.endWalls);

                if (openingsDataForChart.type === 'custom') {
                    if (openingsDataForChart.windows && openingsDataForChart.windows.area > 0) {
                        addDatasetIfRelevant('Window Loss', windowHeatLossData, colors.windows, backgroundColors.windows);
                    }
                    if (openingsDataForChart.doors && openingsDataForChart.doors.area > 0) {
                        addDatasetIfRelevant('Door Loss', doorHeatLossData, colors.doors, backgroundColors.doors);
                    }
                } else { // Percentage based
                     if (actualTotalOpeningAreaForChart > 0) {
                        addDatasetIfRelevant('Generic Openings Loss', genericOpeningsHeatLossData, colors.genericOpenings, backgroundColors.genericOpenings);
                     }
                }

                if (!heatLossChart) {
                    const ctx = document.getElementById('heatLossChart').getContext('2d');
                    heatLossChart = new Chart(ctx, {
                        // type: 'line', // Type can be defined per dataset
                        data: {
                            labels: tempLabels,
                            datasets: datasets
                        },
                        options: {
                             responsive: true,
                             maintainAspectRatio: false,
                             scales: {
                                 y: {
                                     beginAtZero: true,
                                     title: { display: true, text: 'BTU/hr' }
                                 },
                                 x: {
                                      title: { display: true, text: 'Outdoor Temperature' }
                                 }
                             },
                             plugins: {
                                legend: {
                                    display: true // Will be needed for multiple datasets
                                },
                                tooltip: {
                                    callbacks: {
                                        label: function(context) {
                                            return ` ${context.dataset.label}: ${context.raw.toLocaleString()} BTU/hr`;
                                        }
                                    }
                                }
                             }
                        }
                    });
                } else {
                     heatLossChart.data.labels = tempLabels;
heatLossChart.data.datasets = datasets;
                     heatLossChart.update();
                }
            }

            function attachInputListeners() {
                const inputs = document.querySelectorAll('.input-field, input[type="number"]');
                inputs.forEach(input => {
                    // Remove existing to prevent duplicates if run multiple times
                    input.removeEventListener('input', handleInputChange);
                    input.removeEventListener('change', handleInputChange);
                    // Add new combined listener
                    input.addEventListener('input', handleInputChange);
                    input.addEventListener('change', handleInputChange);
                });
            }

            function handleInputChange(event) {
                saveInputToLocalStorage(event.target);
                calculateAll();
            }

            function handleSelectChange(event) {
                saveInputToLocalStorage(event.target);
                // Specific actions for certain selects
                if (event.target.id === 'buildingShape') {
                    updateDimensionInputs(); // This calls calculateAll internally
                } else if (event.target.id === 'openingsArea') {
                    toggleCustomOpenings(); // This calls calculateAll internally
                } else {
                    calculateAll();
                }
            }

            // --- Initial Setup ---
            // Static inputs that trigger recalculation and save their state
            [buildingShape, wallAssembly, openingsArea, airSealing, radiantBarrier].forEach(selectElement => {
                selectElement.removeEventListener('change', handleSelectChange); // Remove if re-running
                selectElement.addEventListener('change', handleSelectChange);
            });

            [customRValue, doubleWallRValue, indoorTemp, outdoorTemp, numWindows, windowArea, windowRValue, numDoors, doorArea, doorRValue].forEach(inputElement => {
                inputElement.removeEventListener('input', handleInputChange); // Remove if re-running
                inputElement.addEventListener('input', handleInputChange);
            });

            // updateDimensionInputs also calls attachInputListeners, which sets up saving for dynamic fields.
            // toggleCustomOpenings is called by openingsArea change listener.

            // --- Load all static inputs from localStorage first ---
            const allStaticInputElements = [
                buildingShape, indoorTemp, outdoorTemp, wallAssembly, customRValue, doubleWallRValue,
                openingsArea, airSealing, radiantBarrier, numWindows, windowArea, windowRValue,
                numDoors, doorArea, doorRValue
            ];
            allStaticInputElements.forEach(el => loadInputFromLocalStorage(el));

            // --- Initial UI setup and calculation ---
            // Call updateDimensionInputs AFTER loading static inputs, especially buildingShape,
            // as it determines which dynamic inputs are created.
            // updateDimensionInputs itself will then load values for those dynamic inputs.
            updateDimensionInputs();

            // Call toggleCustomOpenings AFTER loading static inputs, especially openingsArea.
            toggleCustomOpenings();

            // Final calculation based on all loaded values
            // calculateAll(); // This is already called by updateDimensionInputs and toggleCustomOpenings
        });
    </script>
</body>
</html>
